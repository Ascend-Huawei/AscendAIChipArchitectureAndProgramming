/*
* Copyright (c) Huawei Technologies Co., Ltd. 2017-2018. All rights reserved.
* Description: generated by MindSporeStudio
* Author: Huawei
* Create: 2017-06-06
*/
#include "custom/custom_op.h"
#include "framework/omg/register.h"
#include "framework/omg/omg_types.h"
#include "proto/caffe/caffe.pb.h"
#include "operator.h"
#include "attr_value.h"
#include <memory>
#include <string>
#include <vector>

namespace domi
{
    // Parse the parameters from caffe model, and pass them to the inner model.
    Status CaffeConvolutionParseParams(const Message* op_origin, ge::Operator& op_dest)
    {
        const caffe::LayerParameter* layer = dynamic_cast<const caffe::LayerParameter*>(op_origin);

        // Ckeck operator parameter's validity
        if (nullptr == layer)
        {
            printf("Dynamic cast op_src to LayerParameter failed\n");
            return FAILED;
        }

        // Enum parameter MAP
        std::map<caffe::ConvolutionParameter_Engine, std::string> engine_map = {
            { caffe::ConvolutionParameter_Engine_DEFAULT, "DEFAULT" },
            { caffe::ConvolutionParameter_Engine_CAFFE, "CAFFE" },
            { caffe::ConvolutionParameter_Engine_CUDNN, "CUDNN" },
        };

            // Get parameters handle of current layer
            const caffe::ConvolutionParameter& param = layer->convolution_param();
        unsigned int read_pad = param.pad()[0];
        unsigned int read_stride = param.stride()[0];
        int64_t save_pad = int64_t(read_pad);
        int64_t save_stride = int64_t(read_stride);
            //Parse operator's parameters and register it to inner model(op_dest)
        op_dest.SetAttr("num_output", ge::AttrValue::CreateFrom<ge::AttrValue::INT>(param.num_output()));
        op_dest.SetAttr("bias_term", ge::AttrValue::CreateFrom<ge::AttrValue::BOOL>(param.bias_term()));
        op_dest.SetAttr("pad_h", ge::AttrValue::CreateFrom<ge::AttrValue::INT>(save_pad));
        op_dest.SetAttr("pad_w", ge::AttrValue::CreateFrom<ge::AttrValue::INT>(save_pad));
        op_dest.SetAttr("kernel_h", ge::AttrValue::CreateFrom<ge::AttrValue::INT>(param.kernel_h()));
        op_dest.SetAttr("kernel_w", ge::AttrValue::CreateFrom<ge::AttrValue::INT>(param.kernel_w()));
        op_dest.SetAttr("stride_h", ge::AttrValue::CreateFrom<ge::AttrValue::INT>(save_stride));
        op_dest.SetAttr("stride_w", ge::AttrValue::CreateFrom<ge::AttrValue::INT>(save_stride));
        op_dest.SetAttr("group", ge::AttrValue::CreateFrom<ge::AttrValue::INT>(param.group()));

        op_dest.SetAttr("engine", ge::AttrValue::CreateFrom<ge::AttrValue::STR>(engine_map[ param.engine()]));
        op_dest.SetAttr("axis", ge::AttrValue::CreateFrom<ge::AttrValue::INT>(param.axis()));
        op_dest.SetAttr("force_nd_im2col", ge::AttrValue::CreateFrom<ge::AttrValue::BOOL>(param.force_nd_im2col()));
        return SUCCESS;
    }

    // Function to acquire output tensor descriptor
    Status CaffeConvolutionInferShapeAndType(const ge::Operator& op, vector<ge::TensorDesc>& v_output_desc)
    {
    	auto tensorDesc = op.GetInputDesc(0);
        auto weightDesc = op.GetInputDesc(1);
    	auto shape = tensorDesc.GetShape();
        auto weightshape = weightDesc.GetShape();
        
    	int64_t axis = -1;
        ge::AttrValue axisAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("axis", axisAttrValue)) || (ge::GRAPH_SUCCESS != axisAttrValue.GetValue<ge::AttrValue::INT>(axis)))
        {
            printf("Get axis failed!\n");
        }
        // In the OM model, all shape are supplemented to 4d. In this case, axis needs to be repaired to point to the original 2d.
        if (axis < 0) axis -= 2;

        if (axis < 0) axis += shape.GetDimNum();

        if (axis < 0 || axis >= shape.GetDimNum())
        {
            printf("invalid axis:%d, dim_size:%d\n", (int32_t)axis, (int32_t)shape.GetDimNum());
            return PARAM_INVALID;
        }
        int64_t num_output = 0;
        ge::AttrValue num_outputAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("num_output", num_outputAttrValue))
            || (ge::GRAPH_SUCCESS != num_outputAttrValue.GetValue<ge::AttrValue::INT>(num_output)))
        {
            printf("GetOpAttr num_output  failed!\n");
        }
        int64_t pad_h = 0;
        ge::AttrValue pad_hAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("pad_h", pad_hAttrValue))
            || (ge::GRAPH_SUCCESS != pad_hAttrValue.GetValue<ge::AttrValue::INT>(pad_h)))
        {
            printf("GetOpAttr pad_h  failed!\n");
        }

        int64_t pad_w = 0;
        ge::AttrValue pad_wAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("pad_w", pad_wAttrValue))
            || (ge::GRAPH_SUCCESS != pad_wAttrValue.GetValue<ge::AttrValue::INT>(pad_w)))
        {
            printf("GetOpAttr pad_w  failed!\n");
        }
        int64_t stride_h = 0;
        ge::AttrValue stride_hAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("stride_h", stride_hAttrValue))
            || (ge::GRAPH_SUCCESS != stride_hAttrValue.GetValue<ge::AttrValue::INT>(stride_h)))
        {
            printf("GetOpAttr stride_h  failed!\n");
        }

        int64_t stride_w = 0;
        ge::AttrValue stride_wAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("stride_w", stride_wAttrValue))
            || (ge::GRAPH_SUCCESS != stride_wAttrValue.GetValue<ge::AttrValue::INT>(stride_w)))
        {
            printf("GetOpAttr stride_w  failed!\n");
        }

        int32_t dimsize = (int32_t)shape.GetDimNum();
        shape.SetDim(0, 1);
        shape.SetDim(1, num_output);
        int32_t out_h = (shape.GetDim(2)+pad_h*2-weightshape.GetDim(2)+1)/stride_h;
        int32_t out_w = (shape.GetDim(3)+pad_w*2-weightshape.GetDim(3)+1)/stride_w;
        shape.SetDim(2, out_h);
        shape.SetDim(3, out_w);
        
        tensorDesc.SetShape(shape);
        v_output_desc.push_back(tensorDesc);

        return SUCCESS;
    }

    // Pass the parameters you just parsed from the parseParam() to the op python function
    Status CaffeConvolutionBuildTeBin(const ge::Operator& op, TEBinInfo& te_bin_info)
    {
        std::string FilePath   = "";
        std::string FuncName   = "";
        std::string KernelName = "";

        // Parse operator's parameter and attach exception catching
        int64_t num_output = 0;
        ge::AttrValue num_outputAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("num_output", num_outputAttrValue)) 
            || (ge::GRAPH_SUCCESS != num_outputAttrValue.GetValue<ge::AttrValue::INT>(num_output)))
        {
            printf("GetOpAttr num_output  failed!\n");
        }

        bool bias_term = false;
        ge::AttrValue bias_termAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("bias_term", bias_termAttrValue)) 
            || (ge::GRAPH_SUCCESS != bias_termAttrValue.GetValue<ge::AttrValue::BOOL>(bias_term)))
        {
            printf("GetOpAttr bias_term  failed!\n");
        }

        int64_t pad_h = 0;
        ge::AttrValue pad_hAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("pad_h", pad_hAttrValue)) 
            || (ge::GRAPH_SUCCESS != pad_hAttrValue.GetValue<ge::AttrValue::INT>(pad_h)))
        {
            printf("GetOpAttr pad_h  failed!\n");
        }

        int64_t pad_w = 0;
        ge::AttrValue pad_wAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("pad_w", pad_wAttrValue)) 
            || (ge::GRAPH_SUCCESS != pad_wAttrValue.GetValue<ge::AttrValue::INT>(pad_w)))
        {
            printf("GetOpAttr pad_w  failed!\n");
        }

        int64_t kernel_h = 0;
        ge::AttrValue kernel_hAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("kernel_h", kernel_hAttrValue)) 
            || (ge::GRAPH_SUCCESS != kernel_hAttrValue.GetValue<ge::AttrValue::INT>(kernel_h)))
        {
            printf("GetOpAttr kernel_h  failed!\n");
        }

        int64_t kernel_w = 0;
        ge::AttrValue kernel_wAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("kernel_w", kernel_wAttrValue)) 
            || (ge::GRAPH_SUCCESS != kernel_wAttrValue.GetValue<ge::AttrValue::INT>(kernel_w)))
        {
            printf("GetOpAttr kernel_w  failed!\n");
        }

        int64_t stride_h = 0;
        ge::AttrValue stride_hAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("stride_h", stride_hAttrValue)) 
            || (ge::GRAPH_SUCCESS != stride_hAttrValue.GetValue<ge::AttrValue::INT>(stride_h)))
        {
            printf("GetOpAttr stride_h  failed!\n");
        }

        int64_t stride_w = 0;
        ge::AttrValue stride_wAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("stride_w", stride_wAttrValue)) 
            || (ge::GRAPH_SUCCESS != stride_wAttrValue.GetValue<ge::AttrValue::INT>(stride_w)))
        {
            printf("GetOpAttr stride_w  failed!\n");
        }

        int64_t group = 0;
        ge::AttrValue groupAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("group", groupAttrValue)) 
            || (ge::GRAPH_SUCCESS != groupAttrValue.GetValue<ge::AttrValue::INT>(group)))
        {
            printf("GetOpAttr group  failed!\n");
        }

        std::string engine = "";
        ge::AttrValue engineAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("engine", engineAttrValue)) 
            || (ge::GRAPH_SUCCESS != engineAttrValue.GetValue<ge::AttrValue::STR>(engine)))
        {
            printf("GetOpAttr engine  failed!\n");
        }

        int64_t axis = 0;
        ge::AttrValue axisAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("axis", axisAttrValue)) 
            || (ge::GRAPH_SUCCESS != axisAttrValue.GetValue<ge::AttrValue::INT>(axis)))
        {
            printf("GetOpAttr axis  failed!\n");
        }

        // In the OM model, all shape are supplemented to 4d. In this case, axis needs to be repaired to point to the original 2d.
        if (axis < 0)
        {
            axis -= 2;
        }
        bool force_nd_im2col = false;
        ge::AttrValue force_nd_im2colAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("force_nd_im2col", force_nd_im2colAttrValue)) 
            || (ge::GRAPH_SUCCESS != force_nd_im2colAttrValue.GetValue<ge::AttrValue::BOOL>(force_nd_im2col)))
        {
            printf("GetOpAttr force_nd_im2col  failed!\n");
        }

        // Parse input tensor descriptor
        ge::TensorDesc input_desc = op.GetInputDesc(0);
        ge::TensorDesc weight_desc = op.GetInputDesc(1);

        // Parse input shape, validate if it is equal to 4
        if (input_desc.GetShape().GetDimNum() != 4)
        {
            printf("The shape size is %d, which is not 4!", (int32_t)input_desc.GetShape().GetDimNum());
            return FAILED;
        }

        FilePath   = "/home/ascend/tools/projects/custom_convolution/operator/custom_convolution";
        FuncName   = "conv_layer_cce";
        KernelName = "conv_layer_cce";
 		
    	uint8_t bias = 0;
    	if (bias_term) {
            printf("Use bias is %d, !",bias);
        	bias = 1;
   	 	}

        /* TODO: Pass the parameters to the api function */
        te::BuildTeCustomOp(te_bin_info.ddk_version, op.GetName(), FilePath, FuncName,
                "(i,i,i,i), (i,i,i,i), s, s, s, i, i, i, i, i, s, b, b",
                input_desc.GetShape().GetDim(0), input_desc.GetShape().GetDim(1),
                input_desc.GetShape().GetDim(2), input_desc.GetShape().GetDim(3),
                weight_desc.GetShape().GetDim(0), weight_desc.GetShape().GetDim(1),
                weight_desc.GetShape().GetDim(2), weight_desc.GetShape().GetDim(3),
                "float16", "float16", "float16", pad_h, pad_w, stride_h, stride_w,bias,
                KernelName.c_str(), 1, 0);

        /* TODO: Set the path of the generation files */
        te_bin_info.bin_file_path = "./kernel_meta/" + KernelName + ".o";
        te_bin_info.json_file_path = "./kernel_meta/" + KernelName + ".json";

        return SUCCESS;
    }

     /**
    * Register the op plugin
    * REGISTER_CUSTOM_OP:    Operator type name in om model, can be any but not duplicate with existence. case sensitive
    * FrameworkType:       Enum type, only support CAFFE
    * OriginOpType:        name of the operator type name in CAFFE
    * ParseParamsFn:      Op parameters parse function
    * InferShapeAndTypeFn: Set output description and datatype function
    * TEBinBuildFn:    Class name of op parser
    * ImplyType:           Instantiation type, TVM
    */
    REGISTER_CUSTOM_OP("custom_convolution")
        .FrameworkType(CAFFE)
        .OriginOpType("Convolution")
        .ParseParamsFn(CaffeConvolutionParseParams)
        .InferShapeAndTypeFn(CaffeConvolutionInferShapeAndType)
        .TEBinBuildFn(CaffeConvolutionBuildTeBin)
        .ImplyType(ImplyType::TVM)
        .Formats({DOMI_TENSOR_NC1HWC0}, {DOMI_TENSOR_NC1HWC0})
        .WeightFormats({DOMI_TENSOR_FRACTAL_Z, DOMI_TENSOR_NC1HWC0});  
}

